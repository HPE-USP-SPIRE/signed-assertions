# Transitive Identity & Embedded Claims

## Proof of Concept

This Proof of Concept simulates a banking application. The business logic says that the end user must use an OKTA OAuth token to log in Subject_wl (frontend). The subject_wl will exchange this token for a more restrictive one (DA-SVID), generated by Asserting_wl. The DA-SVID is then used in authorization mechanisms to access end user data.

Each component is a workload with a SPIFFE-ID running in a Docker container. The Asserting Workload is a trusted component allowed to mint new DA-SVID tokens. When the front-end application requires to access the end-user data, it stablishes a SPIRE mTLS connection with Asserting Workload, sending the end-user OAuth token. The Asserting Workload, by its side, receives the OAuth token, mint a DA-SVID (claims described at ... ref doc...) and sign it with a private key (can be its own SVID or another specific key), sending back to Subject Workload and storing OAuth token.

The Middle tiers simulates generic cloud application components (e.g. load balancer), to exemplify the DA-SVID transitivity. In this PoC, when receive requests that uses DA-SVID, it first validate its expiration and signature. After that, the DA-SVID go through all middle tiers, that uses Asserting Workload introspect endpoint to validate the DA-SVID. The valid requests are send to Target Workload.

When Target Workload receives a request with DA-SVID, it check its expiration and signature. If valid, Target Workload parse its claims and verify if DA-SVID subject claim is allowed to use DA-SVID. Then, **TW** extract **dpr claim** and perform a database search for that user, returning the user balance or an error message.

There are two scenarios developed to this proof of concept: 

### Transitivity using ID-mode
![ID-mode](https://github.com/HPE-USP-SPIRE/signed-assertions/blob/main/doc/PoC_1_ecdsa_idmode_flow.jpg)

In ID-mode, the objective is to validate all the nested token signatures using the signer certificate. In this mode, when a workload append new claims to an existing token, it set the issuer as its own public key and the audience with the public key of next hop. Then, the it send both token and certificates to the next hop. Each time new information is added to a token, the signer certificate is added to this trust bundle. The validation consists in two steps: 

1 - Verify if the issuer of Token(n) is the same ID in the audience of Token(n-1).
2 - Retrieve the public keys from the trust bundle and use it to validate all sequential signatures.

The Figure ID-mode depicts the application of ID-mode in the PoC application:

1.  The user log in application using an OKTA OAuth token
2.  The front-end (subject-wl) send the OAuth token to asserting-wl /ecdsaassertion endpoint, that should return a new ECDSA nested token identifying the user and the workload that is allowed to access in behalf of the user.
3.  The asserting-wl mint the new nested token using ECDSA scheme with its private key, retrieved from SPIRE SVID.
4.  Asserting-wl return to front-end the token and its own certificate.
5.  Before sending the token, Front-end add new claims, specifically the issuer (front-end public key) and audience (middle-tier public key). The resulting payload is signed by front-end using its SVID private key. The token and both certificates (asserting-wl and front-end) are sent to middle-tier.
6.  Similarly, middle-tier add the issuer (middle-tier public key) and audience (Target-wl public key) claims. The resulting payload is signed by middle-tier using its SVID private key. The token and all certificates (asserting-wl, front-end, and middle-tier) are sent to Target-wl.
7.  Finally, Target-wl uses all certificates in the receiving order to validate all sequential signatures, identifying the signers and verifying if the issuer/audience link hold for all hops. If all perform correctly, Target-wl return user data to front-end.

### Transitivity using anonymous-mode
![anonymous-mode](https://github.com/HPE-USP-SPIRE/signed-assertions/blob/main/doc/PoC_2_anonymousmode_flow.jpg)


In Anonymous-mode, the objective is not to identify each workload in the token flow, but only to grant that all signatures are valid and that those signatures was created using the correct private key. In this scenario,a customized concatenation signature scheme is applied, where the private key to be used is part of previous signature. This create a signature chain and allow to validade using a scheme based in [Galindo and Garcia](https://doi.org/10.1007/978-3-642-02384-2_9) model. The Figure Anonymous-mode depicts the usage of anonymous-mode in PoC application:

1. The user log in application using an OKTA OAuth token
2. The front-end (subject-wl) send the OAuth token to asserting-wl /mintassertion endpoint, that should return a new Schnorr nested token identifying the user and the workload that is allowed to access in behalf of the user.
3. The asserting-wl generate a new Schnorr key parir and mint the new nested token using the private key.
4. Asserting-wl return the token to front-end.
5. Front-end add the necessary claims, remove part of previous signature and use it as private key, to generate the new signature. Then, front-end send the token to middle-tier.
6. Similarly, all next workloads perform the same routine, adding the necessary claims, removing and using part of previous signature as private key.
7. In the end, the token will be composed of 'n' parts, where only the last is a complete signature, and all previous are partial signatures. Target-wl then use the concatenated signature validation scheme to validate the token.

## Prerequisites

- OKTA account (Application with client ID, client Secret and authorized callback URI)
- Docker
- SPIRE-Server and Agent (host) up and running
- SPIRE entries

## Installation

For a complete manual installation, follow [Step by Step.md](https://github.com/HPE-USP-SPIRE/DASVID_PoC_V0/blob/docker_vr/Step%20by%20Step%20Guide.md) guide.

After download the repository, first change permissions on all scripts to run as executables:

```bash
sudo chmod +x -R *.sh && sudo chmod +x lib/*.sh
```

1. **DO NOT** run any script with extra privileges with sudo. The proper locations to run as sudo are written on each script.

2. Run **requirements.sh** if you do not have all required packages installed.

3. Before you run **installation.sh**, it is necessary to put your data in the **config** file:

   - If you **DO NOT** want to install SPIRE or Docker (probably because you already have it), change values to **TRUE**.
   - Insert your OKTA credentials (client ID, client secret) 
   - Change the HOST IP to the machine IP that will run the application. Change each line accordingly.

## How to use

To config the environemnt according to config file, initialize SPIRE (agent and server) and all docker containers (workloads):

```
chmod +x init
./init
```


To kill SPIRE and the containers

```
./kill
```

_Disclaimer 1: init also runs kill, and both kill all the containers running in the machine!_

## Asserting workload

Asserting Workload is the main component that is responsible for Oauth token validation and DA-SVID minting. To perform its tasks, Asserting WL exposes an API with the necessary endpoints described bellow. All API responses are in JSON format.

To access the API, clients must stablish a mTLS connection with Asserting Workload using its SVID. Asserting workload accepts any connection originated from its trust domain, and clients should accept connections only from specific predefined SPIFFE-IDs (Asserting Workload).

When connected, clients can access /keys, /mint and /introspect endpoints.

### `/keys`
This endpoint does not require any parameter, and returns the public key set necessary to validate DA-SVIDs in JWKS format.


### `/mint <AccessToken>`
|Parameter|Type|Required|Description|
|--|--|--|--|
|`<AccessToken>`|string|yes|Mint a new DA-SVID based in OKTA OAuth token received as  parameter.|

When a mint call is received, the Asserting Workload validate the OAuth token received. If the token is valid, it fetchs the SPIFFE-ID from the current mTLS session and uses it as DA-SVID subject claim. Asserting Workload also fetchs its own SPIFFE-ID and use it as DA-SVID issuer claim.

After DA-SVID claims generation, the token is signed with Asserting Workload private key, that could be its SVID or another specific key. The current implementation uses a specific key, localized in ./keys.

In the end, the Asserting Workload sends to client Oauth token expiration and signature validation results and the generated DA-SVID.

### `/introspect <DA-SVID>`
|Parameter|Type|Required|Description|
|--|--|--|--|
|`<DA-SVID>`|string|yes|Return OAuth token ZKP, given DA-SVID.|

This endpoint return the DA-SVID original claims and a Zero Knowledge Proof (ZKP) in JSON format if a valid OAuth token was used to generate that DA-SVID.

### `/validate <DA-SVID>`
|Parameter|Type|Required|Description|
|--|--|--|--|
|`<DA-SVID>`|string|yes|DA-SVID to be validated.|

This endpoint return the result of expiration time and signature validation of given DA-SVID.

### `/ecdsaassertion <AccessToken>`
|Parameter|Type|Required|Description|
|--|--|--|--|
|`<AccessToken>`|string|yes|Mint a new ECDSA nested token based in OKTA OAuth token received as AccessToken parameter.|

This endpoint return a new ECDSA nested token. Basically it is the same DA-SVID, but in nested model format, insted JWT (2 part token vs 3 part token).

### `/mintassertion <AccessToken>`
|Parameter|Type|Required|Description|
|--|--|--|--|
|`<AccessToken>`|string|yes|Mint a new Schnorr nested token based in OKTA OAuth token received as AccessToken parameter.|

This endpoint return a new Schnorr nested token. Basically it is the same DA-SVID, but in nested model format, insted JWT (2 part token vs 3 part token).

# References

https://developer.okta.com/authentication-guide/implementing-authentication/auth-code#1-setting-up-your-application
