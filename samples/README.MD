# Proof of Concept scenarios

This Proof of Concept simulates a banking application. The business logic says that the end user must use an OKTA OAuth token to log in Subject_wl (front-end). The subject_wl will exchange this token for a more restrictive one (SVID-NG), generated by Asserting_wl. The SVID-NG is then used in authorization mechanisms to access end user data. More details about asserting-wl can be found in its readme (link). The base use case to the developed scenarios is depicted in Figure 1.

![Basic Scenario](https://github.com/HPE-USP-SPIRE/signed-assertions/blob/main/doc/basicscenario.jpg)

In this scenario, each component is a workload with a SPIFFE-ID running in a Docker container. The Local IdP (asserting-wl) is a trusted component allowed to mint new SVID-NG tokens. When the front-end application requires to access the end-user data, it stablishes a SPIRE mTLS connection with Local IdP, sending the end-user OAuth token. The Local IdP, by its side, receives the OAuth token, mint a SVID-NG and sign it with a private key sending back to front end.

The Middle tiers simulates generic cloud application components (e.g. load balancer), to exemplify the SVID-NG transitivity. In this PoC, when receive requests that uses SVID-NG, it first validate its expiration and signature. After that, the SVID-NG go through all middle tiers until reaches the target-wl where a full validation is performed, before authorizing the access to user data. First step is the validation of the SVID-NG signature(s) and mandatory claims. Then, target-wl contacts asserting-wl introspect endpoint to retrieve a ZKP of a valid OAuth token behind given SVID-NG. Finally, target-wl validates received proof and, if all validations are successful, return user data.

During the nested token scheme development, three test scenarios were created to apply and evaluate each of the different constructions. Each subdir contains a specific use case. The SVID-NG was the first use case, containing the SVID-NG and local IdP specification and development. Then, this use case was extended, implementing the ID-mode and anonymous-mode.

You can find more detailed information inside each of the sample's README file

## ID-mode

The workloads uses SPIRE SVID private key to sign the tokens. The user OAuth token is exchanged for an ECDSA assertion, generated by asserting-wl (IdP). Each workload in the application adds new issuer claim with its own public key and audience with next hop public key. and its own signature.  
Together with the token, the workload forward also its trust bundle, allowing for identification and validation offline.

## Anonymous mode

The workloads dont use any IdP. This model do not offer identification of the workloads, but takes advantage of this by using a signature concatenation model that allows for token size reduction and fast validation execution times.
The resulting token is smaller than in ID-mode, as it remove part of the signatures to use as private key. Also, there is no need to send certificates along with the token.

## SVID-NG

The basic model developed in Phase 1 of the project. In this scenario, asserting wl mint a token that allows the delegation of user rights to a workload. The objective of this token (a.k.a. SVID-NG) is to grant that the calling workload have the sufficient rights to access the desired resource.

</br>

## Asserting workload

Asserting Workload is the main component that is responsible for Oauth token validation and DA-SVID minting. To perform its tasks, Asserting WL exposes an API with the necessary endpoints described bellow. All API responses are in JSON format.

To access the API, clients must stablish a mTLS connection with Asserting Workload using its SVID. Asserting workload accepts any connection originated from its trust domain, and clients should accept connections only from specific predefined SPIFFE-IDs (Asserting Workload).

When connected, clients can access /keys, /mint and /introspect endpoints.

### `/keys`

This endpoint does not require any parameter, and returns the public key set necessary to validate DA-SVIDs in JWKS format.

### `/mint <AccessToken>`

| Parameter       | Type   | Required | Description                                                         |
| --------------- | ------ | -------- | ------------------------------------------------------------------- |
| `<AccessToken>` | string | yes      | Mint a new DA-SVID based in OKTA OAuth token received as parameter. |

When a mint call is received, the Asserting Workload validate the OAuth token received. If the token is valid, it fetchs the SPIFFE-ID from the current mTLS session and uses it as DA-SVID subject claim. Asserting Workload also fetchs its own SPIFFE-ID and use it as DA-SVID issuer claim.

After DA-SVID claims generation, the token is signed with Asserting Workload private key, that could be its SVID or another specific key. The current implementation uses a specific key, localized in ./keys.

In the end, the Asserting Workload sends to client Oauth token expiration and signature validation results and the generated DA-SVID.

### `/introspect <DA-SVID>`

| Parameter   | Type   | Required | Description                            |
| ----------- | ------ | -------- | -------------------------------------- |
| `<DA-SVID>` | string | yes      | Return OAuth token ZKP, given DA-SVID. |

This endpoint return the DA-SVID original claims and a Zero Knowledge Proof (ZKP) in JSON format if a valid OAuth token was used to generate that DA-SVID.

### `/validate <DA-SVID>`

| Parameter   | Type   | Required | Description              |
| ----------- | ------ | -------- | ------------------------ |
| `<DA-SVID>` | string | yes      | DA-SVID to be validated. |

This endpoint return the result of expiration time and signature validation of given DA-SVID.

### `/ecdsaassertion <AccessToken>`

| Parameter       | Type   | Required | Description                                                                                |
| --------------- | ------ | -------- | ------------------------------------------------------------------------------------------ |
| `<AccessToken>` | string | yes      | Mint a new ECDSA nested token based in OKTA OAuth token received as AccessToken parameter. |

This endpoint return a new ECDSA nested token. Basically it is the same DA-SVID, but in nested model format, insted JWT (2 part token vs 3 part token).

### `/mintassertion <AccessToken>`

| Parameter       | Type   | Required | Description                                                                                  |
| --------------- | ------ | -------- | -------------------------------------------------------------------------------------------- |
| `<AccessToken>` | string | yes      | Mint a new Schnorr nested token based in OKTA OAuth token received as AccessToken parameter. |

This endpoint return a new Schnorr nested token. Basically it is the same DA-SVID, but in nested model format, insted JWT (2 part token vs 3 part token).

</br></br>
